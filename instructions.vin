//
// instructions.vin
//
// Simulation of the DLX
// Written by Edsko de Vries, Summer 2003
//
// Copyright (C) 2003 - 2018 Edsko de Vries and jones@scss.tcd.ie
//
// This program is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation;
// either version 2 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//


//
// Condition Constants
//

// Number of Conditions
const num MAX_COND = 18;

const num def = 0; 	// Default is equivalent to AL
const num EQ = 1; 		// Z set (Equal)
const num NE = 2; 		// Z clear (Not Equal)
const num HS = 3; 		// C set (Unsigned Higher or same)
const num CS = 4; 		// C set
const num LO = 5; 		// C clear (Unsigned Lower or Same)
const num CC = 6; 		// C clear
const num MI = 7; 		// N set (Negative)
const num PL = 8; 		// N clear (Positive or Zero)
const num VS = 9; 		// V set (Overflow)
const num VC = 10; 		// V clear (No Overflow)
const num HI = 11; 		// C set and Z clear (Unsigned Higher)
const num LS = 12; 		// C clear  or Z set (Unsigned Lower or Same)
const num GE = 13; 		// N set and V set, or N clear and V clear (Greater Than or Equal)
const num LT = 14; 		// N set and V clear, or N clear and V set(Less Than)
const num GT = 15; 		// Z clear, and either N set and V set, or N clear and V clear
const num LE = 16; 		// Z set, or N set and V clear, or N clear and V set (Equal)
const num AL = 17; 		// (Always)
const num NV = 18; 		// (Reserved)

//
// Condition Names
//

string condNames[MAX_COND+1];


condNames[def]= "  "; 	// Default is equivalent to AL
condNames[EQ] = "EQ"; 		// Z set (Equal)
condNames[NE] = "NE"; 		// Z clear (Not Equal)
condNames[HS] = "HS"; 		// C set (Unsigned Higher or same)
condNames[CS] = "CS"; 		// C set
condNames[LO] = "LO"; 		// C clear (Unsigned Lower or Same)
condNames[CC] = "CC"; 		// C clear
condNames[MI] = "MI"; 		// N set (Negative)
condNames[PL] = "PL"; 		// N clear (Positive or Zero)
condNames[VS] = "VS"; 		// V set (Overflow)
condNames[VC] = "VC"; 		// V clear (No Overflow)
condNames[HI] = "HI"; 		// C set and Z clear (Unsigned Higher)
condNames[LS] = "LS"; 		// C clear  or Z set (Unsigned Lower or Same)
condNames[GE] = "GE"; 		// N set and V set, or N clear and V clear (Greater Than or Equal)
condNames[LT] = "LT"; 		// N set and V clear, or N clear and V set(Less Than)
condNames[GT] = "GT"; 		// Z clear, and either N set and V set, or N clear and V clear
condNames[LE] = "LE"; 		// Z set, or N set and V clear, or N clear and V set (Equal)
condNames[AL] = "AL"; 		// (Always)
condNames[NV] = "NV"; 		// (Reserved)


//
// Instruction constants
//

// Number of instructions (excluding "stall" instruction)
const num MAX_INSTR = 54;

// No-op
const num NOP = 0;

// Arithmetic/Logical/Shifting instructions (register-register)

const num ADD   = 1;    // Add
const num ADC	= 2;	// Add with Carry
const num SUB   = 3;    // Subtract
const num SBC	= 4;	// Subtract with Carry
const num RSB	= 5;	// Reverse Subtract
const num RSC	= 6;	// Reverse Subtract with Carry
const num MUL	= 7;	// Multiply

const num AND   = 8;    // Logical AND
const num ORR   = 9;    // Logical OR
const num EOR	= 10;	// Exclusive OR
const num BIC	= 11;	// Bit Clear

const num LSL	= 12;	// Logical Shift Left
const num LSR	= 13;	// Logical Shift Right
const num ASR	= 14;	// Arithmetic Shift RIght
const num ROR	= 15;	// Rotate Right


// Arithmetic/Logical/Shifting instructions (register-immediate)


const num ADDi  = 16;    // Add
const num ADCi	= 17;	// Add with Carry
const num SUBi  = 18;    // Subtract
const num SBCi	= 19;	// Subtract with Carry
const num RSBi	= 20;	// Reverse Subtract
const num RSCi	= 21;	// Reverse Subtract with Carry
const num MULi	= 22;	// Multiply

const num ANDi  = 23;    // Logical AND
const num ORRi  = 24;    // Logical OR
const num EORi	= 25;	// Exclusive OR
const num BICi	= 26;	// Bit Clear

const num LSLi	= 27;	// Logical Shift Left
const num LSRi	= 28;	// Logical Shift Right
const num ASRi	= 29;	// Arithmetic Shift RIght
const num RORi	= 30;	// Rotate Right


// Comparisons (register - register)
const num CMN	= 31;	// Compare Negative
const num CMP	= 32;	// Compare
const num TEQ	= 33;	// Test bitwise equality
const num TST	= 34;	// Test bits

// Comparisons (register - immediate)
const num CMNi	= 35;	// Compare Negative
const num CMPi	= 36;	// Compare
const num TEQi	= 37;	// Test bitwise equality
const num TSTi	= 38;	// Test bits



// Load/store instructions (register - register)
const num MOV	= 39;	// Move register or constant
const num MVN	= 40;	// Move negative register
const num LDR	= 41;   // Load register from memory
const num STR	= 42;   // Store register to memory
const num SWP	= 43;	// Swap register with memory

// Load/store instructions (register - immediate)
const num MOVi	= 44;	// Move register or constant
const num MVNi	= 45;	// Move negative register
const num LDRi	= 46;   // Load register from memory
const num STRi	= 47;   // Store register to memory


// Control instructions (register - register)
const num B		= 48;   // Branch
const num BL	= 49;   // Branch with Link

// Control instructions (register - immediate)
const num Bi	= 50;   // Branch
const num BLi	= 51;   // Branch with Link


// Halt
const num HALT  = 52;   // Stop running

// "Stall" and "Empty" instruction (aliases for NOP)
const num STALL = 53;
const num EMPTY = 54;

//
// Instruction names
//

string instrNames[55];

// NOP
instrNames[NOP] = "NOP";

// Arithmetic //instructions (register-register)
//instrNames[ADD] = "ADD";    // Add
//instrNames[SUB] = "SUB";    // Subtract
//instrNames[AND] = "AND";    // Logical AND
//instrNames[OR]  = "OR";     // Logical OR
//instrNames[XOR] = "XOR";    // Logical exclusive OR
//instrNames[SLL] = "SLL";    // Logical shift left
//instrNames[SRL] = "SRL";    // Logical shift right
//instrNames[SLT] = "SLT";    // Set if less than
//instrNames[SGT] = "SGT";    // Set if greater than
//instrNames[SLE] = "SLE";    // Set if less or equal
//instrNames[SGE] = "SGE";    // Set if greater or equal

// Arithmetic //instructions (register-immediate)
//instrNames[ADDi]    = "ADDi";
//instrNames[SUBi]    = "SUBi";
//instrNames[ANDi]    = "ANDi";
//instrNames[ORi]     = "ORi";
//instrNames[XORi]    = "XORi";
//instrNames[SLLi]    = "SLLi";
//instrNames[SRLi]    = "SRLi";
//instrNames[SLTi]    = "SLTi";
//instrNames[SGTi]    = "SGTi";
//instrNames[SLEi]    = "SLEi";
//instrNames[SGEi]    = "SGEi";

// Load/store //instructions
//instrNames[LD]      = "LD";     // Load             // joj
//instrNames[ST]      = "ST";     // Store            // joj

// Control //instructions
//instrNames[BEQZ]    = "BEQZ";   // Branch if equal to zero
//instrNames[BNEZ]    = "BNEZ";   // Branch if not equal to zero
//instrNames[J]       = "J";      // Jump
//instrNames[JAL]     = "JAL";    // Jump and link
//instrNames[JR]      = "JR";     // Jump register
//instrNames[JALR]    = "JALR";   // Jump and link register

instrNames[ADD] = "ADD";    // Add
instrNames[ADC]	= "ADC";	// Add with Carry
instrNames[SUB] = "SUB";    // Subtract
instrNames[SBC]	= "SBC";	// Subtract with Carry
instrNames[RSB]	= "RSB";	// Reverse Subtract
instrNames[RSC]	= "RSC";	// Reverse Subtract with Carry
instrNames[MUL]	= "MUL";	// Multiply

instrNames[AND] = "AND";    // Logical AND
instrNames[ORR] = "ORR";    // Logical OR
instrNames[EOR]	= "EOR";	// Exclusive OR
instrNames[BIC]	= "BIC";	// Bit Clear
instrNames[LSL]	= "LSL";	// Logical Shift Left
instrNames[LSR]	= "LSR";	// Logical Shift Right
instrNames[ASR]	= "ASR";	// Arithmetic Shift RIght
instrNames[ROR]	= "ROR";	// Rotate Right


// Arithmetic/Logical/Shifting instructions (register-immediate)


instrNames[ADDi] = "ADD(i)";    // Add
instrNames[ADCi] = "ADC(i)";	// Add with Carry
instrNames[SUBi] = "SUB(i)";    // Subtract
instrNames[SBCi] = "SBC(i)";	// Subtract with Carry
instrNames[RSBi] = "RSB(i)";	// Reverse Subtract
instrNames[RSCi] = "RSC(i)";	// Reverse Subtract with Carry
instrNames[MULi] = "MUL(i)";	// Multiply

instrNames[ANDi] = "AND(i)";    // Logical AND
instrNames[ORRi] = "ORR(i)";    // Logical OR
instrNames[EORi] = "EOR(i)";	// Exclusive OR
instrNames[BICi] = "BIC(i)";	// Bit Clear

instrNames[LSLi] = "LSL(i)";	// Logical Shift Left
instrNames[LSRi] = "LSR(i)";	// Logical Shift Right
instrNames[ASRi] = "ASR(i)";	// Arithmetic Shift RIght
instrNames[RORi] = "ROR(i)";	// Rotate Right


// Comparisons (register - register)
instrNames[CMN]	= "CMN";	// Compare Negative
instrNames[CMP]	= "CMP";	// Compare
instrNames[TEQ]	= "TEQ";	// Test bitwise equality
instrNames[TST]	= "TST";	// Test bits

// Comparisons (register - immediate)
instrNames[CMNi]	= "CMN(i)";	// Compare Negative
instrNames[CMPi]	= "CMP(i)";	// Compare
instrNames[TEQi]	= "TEQ(i)";	// Test bitwise equality
instrNames[TSTi]	= "TST(i)";	// Test bits


// Load/store instructions (register - register)
instrNames[MOV]	= "MOV";	// Move register or constant
instrNames[MVN]	= "MVN";	// Move negative register
instrNames[LDR]	= "LDR";   // Load register from memory
instrNames[STR]	= "STR";   // Store register to memory
instrNames[SWP]	= "SWP";	// Swap register with memory

// Load/store instructions (register - immediate)
instrNames[MOVi]	= "MOV(i)";	// Move register or constant
instrNames[MVNi]	= "MVN(i)";	// Move negative register
instrNames[LDRi]	= "LDR(i)";   // Load register from memory
instrNames[STRi]	= "STR(i)";   // Store register to memory


// Control instructions (register - register)
instrNames[B]	= "B";   // Branch
instrNames[BL]	= "BL";   // Branch with Link

// Control instructions (register - register)
instrNames[Bi]	= "B(i)";   // Branch
instrNames[BLi]	= "BL(i)";   // Branch with Link


// Halt
instrNames[HALT]    = "HALT";

// "Stall" instruction
instrNames[STALL]   = "STALL";
instrNames[EMPTY] = "EMPTY";

//
// Instruction classes
//
num function instrIsNop(num instr) {
    return (instr == NOP || instr == STALL || instr == EMPTY || instr == HALT) ? 1 : 0; // {joj 28/10/06}
}

num function instrIsArRR(num instr) {
    //return (instr >= ADD && instr <= SGE) ? 1 : 0;          // {joj 28/10/06}
	return (instr >= ADD && instr <= ROR) ? 1 : 0;
}

num function instrIsArRI(num instr) {
    return ((instr >= ADDi) && (instr <= RORi)) ? 1 : 0;	// {joj 28/10/06}
	return 0;
}

num function instrIsBranch(num instr) {
    //return ((instr == BEQZ) || (instr == BNEZ)) ? 1 : 0;    // {joj 28/10/06}
	return (instr >= B && instr <= BLi) ? 1 : 0;
}

//num function isJorJAL(num instr) {							// {joj 3/11/12}
//    //return ((instr == J) || (instr == JAL)) ? 1 : 0;        // {joj 28/10/06}
//	return ((instr == B) || (instr == BL)) ? 1 : 0;
//}

//num function instrIsJumpR(num instr) {						
    //return ((instr == JR) || (instr == JALR)) ? 1 : 0;		// {joj 28/10/06}
//	return 0;
//}

//num function instrIsBranchOrJump(num instr) {
//    return (instrIsBranch(instr) || isJorJAL(instr) || instrIsJumpR(instr)) ? 1 : 0;    // {joj 28/10/06}
//}

//num function instrIsJumpAndLink(num instr) {
    //return ((instr == JAL) || (instr == JALR)) ? 1 : 0;     // {joj 28/10/06}
//    return (instr == BL) ? 1 : 0;     // {joj 28/10/06}
//}

num function instrIsLoadOrStore(num instr) {
    //return ((instr == LD) || (instr == ST)) ? 1 : 0;            // {joj 28/10/06}
    return ((instr == LDR) || (instr == STR)) ? 1 : 0;            // {joj 28/10/06}
}

// My ones
// Shift immediate

num function instrIsShI(num instr) {
	return (instr >= LSLi && instr <= RORi) ? 1 : 0;
}

// instructions with no destination register Register - Register
num function instrHasNoDstRR(num instr) {
	return ((instr >= CMN && instr <= TST)|| instrIsBranch(instr)) ? 1 : 0;
}

// instructions with no destination register Register - Immediate
num function instrHasNoDstRI(num instr) {
	return ((instr >= CMNi && instr <= TSTi) || instrIsBranch(instr)) ? 1 : 0;
}

// instructions with no op2 Register - Register
num function instrHasNoOp1RR(num instr) {
	return ((instr >= MOV && instr <= SWP)) ? 1 : 0;
}

// instructions with no op2 Register - Immediate
num function instrHasNoOp1RI(num instr) {
	return ((instr >= MOVi && instr <= STRi)) ? 1 : 0;
}


//
// Instruction operand types
//
const num OP_TYPE_UNUSED = 0;
const num OP_TYPE_REG = 1;
const num OP_TYPE_IMM = 2;

num function instrOpTypeRdt(num instr) {
    if (instrIsNop(instr) || instrHasNoDstRR(instr) || instrHasNoDstRI(instr))
        return OP_TYPE_UNUSED;
    else
        return OP_TYPE_REG;
}

num function instrOpTypeRs1(num instr) {
    if (instrIsNop(instr) || instrHasNoOp1RR(instr) ||  instrHasNoOp1RI(instr))
        return OP_TYPE_UNUSED;
	else if (instr == Bi || instr == BLi)
		return OP_TYPE_IMM;
    else
        return OP_TYPE_REG;
}

num function instrOpTypeRs2(num instr) {
    if (instrIsNop(instr) || instrIsBranch(instr))
        return OP_TYPE_UNUSED;
    else if (instrIsArRR(instr) || instrHasNoDstRR(instr)  ||  instrHasNoOp1RR(instr))
        return OP_TYPE_REG;
    else
        return OP_TYPE_IMM;
}

num function instrOpTypeRs3(num instr2) {
    if (instrIsNop(instr2))
        return OP_TYPE_UNUSED;
    else if (instrIsShI(instr2))
        return OP_TYPE_IMM;
    else
        return OP_TYPE_REG;
}

//
// Instruction formatting
//
//string function instrText(num instr, num rdt, num rs1, num rs2) {				// {joj 28/10/10}
//    if (instrIsNop(instr))
//        return sprintf("%s", instrNames[instr]);                             	// {joj 28/10/10}
//    else if (instrIsArRR(instr))
//        return sprintf("%s R%d,R%d,R%d", instrNames[instr], rdt, rs1, rs2);  	// {joj 28/10/10}
//    else if (instrIsArRI(instr))
//        return sprintf("%s R%d,R%d,%02X", instrNames[instr], rdt, rs1, rs2); 	// {joj 28/10/10}
//    else if (instr == LD)														// {joj}
//       return sprintf("LD R%d,R%d+%02X", rdt, rs1, rs2);                     	// {joj 28/10/06}
//    else if (instr == ST)                                                		// {joj 28/10/06}
//        return sprintf("ST R%d,R%d+%02X", rdt, rs1, rs2);                    	// {joj 28/10/06}
//    else if (instrIsBranch(instr))
//        return sprintf("%s R%d,%02X", instrNames[instr], rs1, rs2);          	// {joj 28/10/10}
//    else if (instr == J)
//        return sprintf("%s %02X", instrNames[instr], rs2);                   	// {joj 28/10/10}
//    else if (instr == JAL)
//        return sprintf("%s R%d, %02X", instrNames[instr], rdt, rs2);         	// {joj 28/10/10}
//    else if (instr == JR)
//        return sprintf("%s R%d", instrNames[instr], rs2);                    	// {joj 28/10/10}
//    else if (instr == JALR)
//        return sprintf("%s R%d, R%d", instrNames[instr], rdt, rs2);          	// {joj 28/10/10}
//    return "EMPTY";                                                         	// {joj 28/10/10}
//}

string function instrText(num instr, num rdt, num rs1, num rs2, num instr2, num rs3) {				// {joj 28/10/10}
    if (instrIsNop(instr))
        return sprintf("%s", instrNames[instr]);                             	// {joj 28/10/10}
    else if (instrIsArRR(instr))
        return sprintf("%s R%d,R%d,R%d", instrNames[instr], rdt, rs1, rs2);  	// {joj 28/10/10}
    else if (instrIsArRI(instr))
        return sprintf("%s R%d,R%d,%02X", instrNames[instr], rdt, rs1, rs2); 	// {joj 28/10/10}
    else if (instr == LDR)														// {joj}
       return sprintf("LDR R%d,R%d+%02X", rdt, rs1, rs2);                     	// {joj 28/10/06}
    else if (instr == STR)                                                		// {joj 28/10/06}
        return sprintf("STR R%d,R%d+%02X", rdt, rs1, rs2);                    	// {joj 28/10/06}
    else if (instrIsBranch(instr))
        return sprintf("%s R%d,%02X", instrNames[instr], rs1, rs2);          	// {joj 28/10/10}
    else if (instr == B)
        return sprintf("%s %02X", instrNames[instr], rs2);                   	// {joj 28/10/10}
    else if (instr == BL)
        return sprintf("%s R%d, %02X", instrNames[instr], rdt, rs2);         	// {joj 28/10/10}
    return "EMPTY";                                                         	// {joj 28/10/10}
}

//
// Execution
//

// 8-bit sign extension
num function se8(num t) {
    if (t & 0x80)
        return (-1 ^ 0xFF | t);
    else
        return t;
}


// Check Condition Codes
num function isN(num val){
	if(val & 0x80)
		return 1;
	else
		return 0;
}

num function isZ(num val){
	if(val == 0)
		return 1;
	else
		return 0;
}

num function isAddC(num op1, num op2){
	if((op1 + op2) & 0x100)
		return 1;
	else
		return 0;
}

num function isSubC(num op1, num op2){
	if((op1 + op2) & 0x100)
		return 0;
	else
		return 1;
}

num function isAddV(num op1, num op2, num res){
	if(((op1 & 0x80) == (op2 & 0x80)) && ((res & 0x80) != (op1 & 0x80))) {
		return 1;
	} else {
		return 0;
	}
}

num function isSubV(num op1, num op2, num res){
	if(((op1 & 0x80) != (op2 & 0x80)) && ((res & 0x80) != (op1 & 0x80)))
		return 1;
	else
		return 0;
}


//Function to set flags based on res, op1 and op2
num function setFlags(num res, num op1, num op2, num add) {
	cpsr.setNValue(isN(res&0xFF));
	cpsr.setZValue(isZ(res&0xFF));
	if(add){
		cpsr.setCValue(isAddC(se8(op1),se8(op2)));
		cpsr.setVValue(isAddV(se8(op1),se8(op2),(res&0xFF)));
	} else {
		cpsr.setCValue(isSubC(se8(op1),se8(op2)));
		cpsr.setVValue(isSubV(se8(op1),se8(op2),(res&0xFF)));
	}
}

//Test Condition On Function
num function testCondition(num cond) {
	
	if(cond == def || cond == AL) {	//Always
		return 1;
	} else if (cond == EQ) { 		// Z set (cond) {= Equal)
		return(cpsr.z);
	} else if (cond == NE) { 		// Z clear (cond) {= Not Equal)
		return(!cpsr.z);
	} else if (cond == HS) { 		// C set (cond) {= Unsigned Higher or same)
		return(cpsr.c);
	} else if (cond == CS) { 		// C set
		return(cpsr.c);
	} else if (cond == LO) { 		// C clear (cond) {= Unsigned Lower or Same)
		return(!cpsr.c);
	} else if (cond == CC) { 		// C clear
		return(!cpsr.c);
	} else if (cond == MI) { 		// N set (cond) {= Negative)
		return(cpsr.n);
	} else if (cond == PL) { 		// N clear (cond) {= Positive or Zero)
		return(!cpsr.n);
	} else if (cond == VS) { 		// V set (cond) {= Overflow)
		return(cpsr.v);
	} else if (cond == VC) { 		// V clear (cond) {= No Overflow)
		return(!cpsr.v);
	} else if (cond == HI) { 		// C set and Z clear (cond) {= Unsigned Higher)
		return(cpsr.c && !cpsr.z);
	} else if (cond == LS) { 		// C clear  or Z set (cond) {= Unsigned Lower or Same)
		return(!cpsr.c || cpsr.z);
	} else if (cond == GE) { 		// N set and V set, or N clear and V clear (cond) {= Greater Than or Equal)
		return((cpsr.n && cpsr.v) || (!cpsr.n && !cpsr.v));
	} else if (cond == LT) { 		// N set and V clear, or N clear and V set(cond) {= Less Than)
		return((cpsr.n && !cpsr.v) || (!cpsr.n && cpsr.v));
	} else if (cond == GT) { 		// Z clear, and either N set and V set, or N clear and V clear
		return(!cpsr.z && ((cpsr.n && cpsr.v) || (!cpsr.n && !cpsr.v)));
	} else if (cond == LE) { 		// Z set, or N set and V clear, or N clear and V set (cond) {= Equal)
		return(cpsr.z || (cpsr.n && !cpsr.v) || (!cpsr.n && cpsr.v));
	} else if (cond == NV) { 		// (cond) {= Reserved)
		return 0;
	}
}

num function instrExecute(num instr, string s, num cond, num op1, num op2, num n, num z, num c, num v) {
//    if (instr == ADD || instr == ADDi)
//        return (se8(op1) + se8(op2)) & 0xFF;
//    else if (instr == SUB || instr == SUBi)
//        return (se8(op1) - se8(op2)) & 0xFF;
//    else if (instr == AND || instr == ANDi)
//        return op1 & op2;
//    else if (instr == OR || instr == ORi)
//        return op1 | op2;
//    else if (instr == XOR || instr == XORi)
//        return op1 ^ op2;
//    else if (instr == SLL || instr == SLLi)
//        return (op1 << op2) & 0xFF;
//    else if (instr == SRL || instr == SRLi)
//        return (op1 >> op2) & 0xFF;
//    else if (instr == SLT || instr == SLTi)
//        return op1 < op2 ? 1 : 0;
//    else if (instr == SGT || instr == SGTi)
//        return op1 > op2 ? 1 : 0;
//    else if (instr == SLE || instr == SLEi)
//        return op1 <= op2 ? 1 : 0;
//    else if (instr == SGE || instr == SGEi)
//        return op1 >= op2 ? 1 : 0;
//    else if (instr == LD || instr == ST)                 // joj
//        return (se8(op1) + se8(op2)) & 0xFF;
//    else if (instr == JAL || instr == JALR)
//        return op2;
//    else
//        return 0xEE;





	num res = 0;				// Init result to zero	
	num add = 0;				// Initi is Add instruction	to zero

    if (instr == ADD || instr == ADDi) {
        res = (se8(op1) + se8(op2)) & 0xFF;
		add = 1;
    } else if (instr == SUB || instr == SUBi) {
        res = (se8(op1) - se8(op2)) & 0xFF;
    } else if (instr == AND || instr == ANDi) {
        res = op1 & op2;
    } else if (instr == ORR || instr == ORRi) {
        res = op1 | op2;
    } else if (instr == EOR || instr == EORi) {
        res = op1 ^ op2;
    } else if (instr == LSL || instr == LSLi) {
        res = (op1 << op2) & 0xFF;
    } else if (instr == LSR || instr == LSRi) {
        res = (op1 >> op2) & 0xFF;
    } else if (instr == LDR || instr == LDRi || instr == STR || instr == STRi)   {               // joj
        res = (se8(op1) + se8(op2)) & 0xFF;
		add = 1;
	} else if (instr == ADC || instr == ADCi) {
        res = (se8(op1) + se8(op2) + c) & 0xFF;
		add = 1;
	} else if (instr == BIC || instr == BICi) {
		res = (op1 & (~op2));
	} else if (instr == CMN || instr == CMNi) {
		res = se8(op1) + se8(op2);
		add = 1;
		setFlags(res,op1,op2,add);
	}
	else if (instr == CMP || instr == CMPi) {
		res = se8(op1) - se8(op2);
		setFlags(res,op1,op2,add);
	}
	else if (instr == MOV || instr == MOVi) {
		res =((op2) & 0xFF);
	}
	else if (instr == MUL || instr == MULi) { // Multiply ********(If S set V preserved)******************
		res =((op1 * op2) & 0xFF);
	}
	else if (instr == MVN || instr == MVNi) {
		res =((~op2) & 0xFF);
	}
	else if (instr == RSB || instr == RSBi) {
		res = (se8(op2) - se8(op1)) & 0xFF;
	} else if (instr == RSC || instr == RSCi) {
		res = (se8(op2) - se8(op1)-1+c) & 0xFF;
	} else if (instr == SBC || instr == SBCi) {
		res = (se8(op1) - se8(op2)-1+c) & 0xFF;
	} else if (instr == ASR || instr == ASRi) {
		num neg = op1 >> 7;
		if(op2 > 8) op2 = 8;	//If shifting by more than register size
		if(neg){
			op1 = op1 ^ 0xFF00;		//introduce ones before if negative to be shifted into place
		}
		res = (op1 >> op2) & 0xFF;
	}
	else if (instr == ROR || instr == RORi) {
		op2 = op2 % 8;		//modulo by max shift to remove need for loop
		num newLeftPart = (op1 << (8 - op2)) & 0xFF;
		num newRightPart = (op1 >> op2) & 0xFF;
		res = newLeftPart + newRightPart;
	}
//instrNames[SWP]	= "SWP";	// Swap register with memory
	else if (instr == TEQ || instr == TEQi) {
		res = se8(op1) ^ se8(op2);
		setFlags(res,op1,op2,add);
	}
	else if (instr == TST || instr == TSTi) {
		res = se8(op1) & se8(op2);
		setFlags(res,op1,op2,add);
	}
    else if (instr == B || instr == BL) {
        res = op2;
    } else {
        res = 0xEE;
	}
	
	
	// If S set, set CPSR
	if(s == "S"){
		setFlags(res,op1,op2,add);
	}

	// 
 
	return res;
}

// eof