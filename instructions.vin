//
// instructions.vin
//
// Simulation of the DLX
// Written by Edsko de Vries, Summer 2003
//
// Copyright (C) 2003 - 2018 Edsko de Vries and jones@scss.tcd.ie
//
// This program is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation;
// either version 2 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//

//
// Instruction constants
//

// Number of instructions (excluding "stall" instruction)
const num MAX_INSTR = 31;

// No-op
const num NOP = 0;

// Arithmetic instructions (register-register)
//const num ADD   = 1;    // Add
//const num SUB   = 2;    // Subtract
//const num AND   = 3;    // Logical AND
//const num OR    = 4;    // Logical OR
//const num XOR   = 5;    // Logical exclusive OR
//const num SLL   = 6;    // Logical shift left
//const num SRL   = 7;    // Logical shift right
//const num SLT   = 8;    // Set if less than
//const num SGT   = 9;    // Set if greater than
//const num SLE   = 10;   // Set if less or equal
//const num SGE   = 11;   // Set if greater or equal
const num ADD   = 1;    // Add
const num SUB   = 2;    // Subtract
const num AND   = 3;    // Logical AND
const num ORR   = 4;    // Logical OR
const num EOR	= 5;	// Exclusive OR
const num LSL	= 6;	// Logical Shift Left
const num LSR	= 7;	// Logical Shift Right

const num ADC	= 8;	// Add with Carry
const num BIC	= 9;	// Bit Clear
const num CMN	= 10;	// Compare Negative
const num CMP	= 11;	// Compare
const num MOV	= 12;	// Move register or constant
const num MUL	= 13;	// Multiply
const num MVN	= 14;	// Move negative register
const num RSB	= 15;	// Reverse Subtract
const num RSC	= 16;	// Reverse Subtract with Carry
const num SBC	= 17;	// Subtract with Carry
const num ASR	= 18;	// Arithmetic Shift RIght
const num ROR	= 19;	// Rotate Right




const num SWP	= 20;	// Swap register with memory
const num TEQ	= 21;	// Test bitwise equality
const num TST	= 22;	// Test bits


// Arithmetic instructions (register-immediate)
//const num ADDi  = 12;
//const num SUBi  = 13;
//const num ANDi  = 14;
//const num ORi   = 15;
//const num XORi  = 16;
//const num SLLi  = 17;
//const num SRLi  = 18;
//const num SLTi  = 19;
//const num SGTi  = 20;
//const num SLEi  = 21;
//const num SGEi  = 22;

// Load/store instructions
//const num LD    = 23;   // Load             // joj
//const num ST    = 24;   // Store            // joj
const num LDR	= 23;   // Load register from memory
const num STR	= 24;   // Store register to memory
const num LDM	= 25;   // Load multiple registers
const num STM	= 26;   // Store Multiple


// Control instructions
//const num BEQZ  = 25;   // Branch if equal to zero
//const num BNEZ  = 26;   // Branch if not equal to zero
//const num J     = 27;   // Jump
//const num JAL   = 28;   // Jump and link
//const num JR    = 29;   // Jump register
//const num JALR  = 30;   // Jump and link register


const num B		= 27;   // Branch
const num BL	= 28;   // Branch with Link
const num BX	= 29;   // Branch and Exchange




// Halt
const num HALT  = 31;   // Stop running

// "Stall" and "Empty" instruction (aliases for NOP)
const num STALL = 32;
const num EMPTY = 33;

//
// Instruction names
//

string instrNames[34];

// NOP
instrNames[NOP] = "NOP";

// Arithmetic //instructions (register-register)
//instrNames[ADD] = "ADD";    // Add
//instrNames[SUB] = "SUB";    // Subtract
//instrNames[AND] = "AND";    // Logical AND
//instrNames[OR]  = "OR";     // Logical OR
//instrNames[XOR] = "XOR";    // Logical exclusive OR
//instrNames[SLL] = "SLL";    // Logical shift left
//instrNames[SRL] = "SRL";    // Logical shift right
//instrNames[SLT] = "SLT";    // Set if less than
//instrNames[SGT] = "SGT";    // Set if greater than
//instrNames[SLE] = "SLE";    // Set if less or equal
//instrNames[SGE] = "SGE";    // Set if greater or equal

// Arithmetic //instructions (register-immediate)
//instrNames[ADDi]    = "ADDi";
//instrNames[SUBi]    = "SUBi";
//instrNames[ANDi]    = "ANDi";
//instrNames[ORi]     = "ORi";
//instrNames[XORi]    = "XORi";
//instrNames[SLLi]    = "SLLi";
//instrNames[SRLi]    = "SRLi";
//instrNames[SLTi]    = "SLTi";
//instrNames[SGTi]    = "SGTi";
//instrNames[SLEi]    = "SLEi";
//instrNames[SGEi]    = "SGEi";

// Load/store //instructions
//instrNames[LD]      = "LD";     // Load             // joj
//instrNames[ST]      = "ST";     // Store            // joj

// Control //instructions
//instrNames[BEQZ]    = "BEQZ";   // Branch if equal to zero
//instrNames[BNEZ]    = "BNEZ";   // Branch if not equal to zero
//instrNames[J]       = "J";      // Jump
//instrNames[JAL]     = "JAL";    // Jump and link
//instrNames[JR]      = "JR";     // Jump register
//instrNames[JALR]    = "JALR";   // Jump and link register

instrNames[ADD]	= "ADD";    // Add
instrNames[SUB]	= "SUB";    // Subtract
instrNames[AND]	= "AND";    // Logical AND
instrNames[ORR]	= "ORR";    // Logical OR
instrNames[EOR]	= "EOR";	// Exclusive OR
instrNames[LSL]	= "LSL";	// Logical Shift Left
instrNames[LSR]	= "LSR";	// Logical Shift Right
instrNames[ADC]	= "ADC";	// Add with Carry
instrNames[BIC]	= "BIC";	// Bit Clear
instrNames[CMN]	= "CMN";	// Compare Negative
instrNames[CMP]	= "CMP";	// Compare
instrNames[MOV]	= "MOV";	// Move register or constant
instrNames[MUL]	= "MUL";	// Multiply
instrNames[MVN]	= "MVN";	// Move negative register
instrNames[RSB]	= "RSB";	// Reverse Subtract
instrNames[RSC]	= "RSC";	// Reverse Subtract with Carry
instrNames[SBC]	= "SBC";	// Subtract with Carry
instrNames[ASR]	= "ASR";	// Arithmetic Shift RIght
instrNames[ROR]	= "ROR";	// Rotate Right
instrNames[SWP]	= "SWP";	// Swap register with memory
instrNames[TEQ]	= "TEQ";	// Test bitwise equality
instrNames[TST]	= "TST";	// Test bits
instrNames[LDR]	= "LDR";   // Load register from memory
instrNames[STR]	= "STR";   // Store register to memory
instrNames[LDM]	= "LDM";   // Load multiple registers
instrNames[STM]	= "STM";   // Store Multiple
instrNames[B]	= "B";   // Branch
instrNames[BL]	= "BL";   // Branch with Link
instrNames[BX]	= "BX";   // Branch and Exchange


// Halt
instrNames[HALT]    = "HALT";

// "Stall" instruction
instrNames[STALL]   = "STALL";
instrNames[EMPTY] = "EMPTY";

//
// Instruction classes
//
num function instrIsNop(num instr) {
    return (instr == NOP || instr == STALL || instr == EMPTY || instr == HALT) ? 1 : 0; // {joj 28/10/06}
}

num function instrIsArRR(num instr) {
    //return (instr >= ADD && instr <= SGE) ? 1 : 0;          // {joj 28/10/06}
	return (instr >= ADD && instr <= ROR) ? 1 : 0;
}

//-------Commenting out for the miinute
num function instrIsArRI(num instr) {
    //return ((instr >= ADDi) && (instr <= SGEi)) ? 1 : 0;	// {joj 28/10/06}
	return 0;
}

num function instrIsBranch(num instr) {
    //return ((instr == BEQZ) || (instr == BNEZ)) ? 1 : 0;    // {joj 28/10/06}
	return (instr == BX) ? 1 : 0;
}

num function isJorJAL(num instr) {							// {joj 3/11/12}
    //return ((instr == J) || (instr == JAL)) ? 1 : 0;        // {joj 28/10/06}
	return ((instr == B) || (instr == BL)) ? 1 : 0;
}

num function instrIsJumpR(num instr) {						
    //return ((instr == JR) || (instr == JALR)) ? 1 : 0;		// {joj 28/10/06}
	return 0;
}

num function instrIsBranchOrJump(num instr) {
    return (instrIsBranch(instr) || isJorJAL(instr) || instrIsJumpR(instr)) ? 1 : 0;    // {joj 28/10/06}
}

num function instrIsJumpAndLink(num instr) {
    //return ((instr == JAL) || (instr == JALR)) ? 1 : 0;     // {joj 28/10/06}
    return (instr == BL) ? 1 : 0;     // {joj 28/10/06}
}

num function instrIsLoadOrStore(num instr) {
    //return ((instr == LD) || (instr == ST)) ? 1 : 0;            // {joj 28/10/06}
    return ((instr == LDR) || (instr == STR)) ? 1 : 0;            // {joj 28/10/06}
}

//
// Instruction operand types
//
const num OP_TYPE_UNUSED = 0;
const num OP_TYPE_REG = 1;
const num OP_TYPE_IMM = 2;

num function instrOpTypeRdt(num instr) {
    if (instrIsArRR(instr) || instrIsArRI(instr) || instrIsJumpAndLink(instr) || instrIsLoadOrStore(instr))
        return OP_TYPE_REG;
    else
        return OP_TYPE_UNUSED;
}

num function instrOpTypeRs1(num instr) {
    if (instrIsNop(instr) || instrIsJumpR(instr) || isJorJAL(instr))
        return OP_TYPE_UNUSED;
    else
        return OP_TYPE_REG;
}

num function instrOpTypeRs2(num instr) {
    if (instrIsNop(instr))
        return OP_TYPE_UNUSED;
    else if (instrIsArRR(instr) || instrIsJumpR(instr))
        return OP_TYPE_REG;
    else
        return OP_TYPE_IMM;
}

//
// Instruction formatting
//
//string function instrText(num instr, num rdt, num rs1, num rs2) {				// {joj 28/10/10}
//    if (instrIsNop(instr))
//        return sprintf("%s", instrNames[instr]);                             	// {joj 28/10/10}
//    else if (instrIsArRR(instr))
//        return sprintf("%s R%d,R%d,R%d", instrNames[instr], rdt, rs1, rs2);  	// {joj 28/10/10}
//    else if (instrIsArRI(instr))
//        return sprintf("%s R%d,R%d,%02X", instrNames[instr], rdt, rs1, rs2); 	// {joj 28/10/10}
//    else if (instr == LD)														// {joj}
//       return sprintf("LD R%d,R%d+%02X", rdt, rs1, rs2);                     	// {joj 28/10/06}
//    else if (instr == ST)                                                		// {joj 28/10/06}
//        return sprintf("ST R%d,R%d+%02X", rdt, rs1, rs2);                    	// {joj 28/10/06}
//    else if (instrIsBranch(instr))
//        return sprintf("%s R%d,%02X", instrNames[instr], rs1, rs2);          	// {joj 28/10/10}
//    else if (instr == J)
//        return sprintf("%s %02X", instrNames[instr], rs2);                   	// {joj 28/10/10}
//    else if (instr == JAL)
//        return sprintf("%s R%d, %02X", instrNames[instr], rdt, rs2);         	// {joj 28/10/10}
//    else if (instr == JR)
//        return sprintf("%s R%d", instrNames[instr], rs2);                    	// {joj 28/10/10}
//    else if (instr == JALR)
//        return sprintf("%s R%d, R%d", instrNames[instr], rdt, rs2);          	// {joj 28/10/10}
//    return "EMPTY";                                                         	// {joj 28/10/10}
//}

string function instrText(num instr, num rdt, num rs1, num rs2, num instr2, num rs3) {				// {joj 28/10/10}
    if (instrIsNop(instr))
        return sprintf("%s", instrNames[instr]);                             	// {joj 28/10/10}
    else if (instrIsArRR(instr))
        return sprintf("%s R%d,R%d,R%d", instrNames[instr], rdt, rs1, rs2);  	// {joj 28/10/10}
    else if (instrIsArRI(instr))
        return sprintf("%s R%d,R%d,%02X", instrNames[instr], rdt, rs1, rs2); 	// {joj 28/10/10}
    else if (instr == LDR)														// {joj}
       return sprintf("LDR R%d,R%d+%02X", rdt, rs1, rs2);                     	// {joj 28/10/06}
    else if (instr == STR)                                                		// {joj 28/10/06}
        return sprintf("STR R%d,R%d+%02X", rdt, rs1, rs2);                    	// {joj 28/10/06}
    else if (instrIsBranch(instr))
        return sprintf("%s R%d,%02X", instrNames[instr], rs1, rs2);          	// {joj 28/10/10}
    else if (instr == B)
        return sprintf("%s %02X", instrNames[instr], rs2);                   	// {joj 28/10/10}
    else if (instr == BL)
        return sprintf("%s R%d, %02X", instrNames[instr], rdt, rs2);         	// {joj 28/10/10}
    return "EMPTY";                                                         	// {joj 28/10/10}
}

//
// Execution
//

// 8-bit sign extension
num function se8(num t) {
    if (t & 0x80)
        return (-1 ^ 0xFF | t);
    else
        return t;
}

num function instrExecute(num instr, num op1, num op2) {
//    if (instr == ADD || instr == ADDi)
//        return (se8(op1) + se8(op2)) & 0xFF;
//    else if (instr == SUB || instr == SUBi)
//        return (se8(op1) - se8(op2)) & 0xFF;
//    else if (instr == AND || instr == ANDi)
//        return op1 & op2;
//    else if (instr == OR || instr == ORi)
//        return op1 | op2;
//    else if (instr == XOR || instr == XORi)
//        return op1 ^ op2;
//    else if (instr == SLL || instr == SLLi)
//        return (op1 << op2) & 0xFF;
//    else if (instr == SRL || instr == SRLi)
//        return (op1 >> op2) & 0xFF;
//    else if (instr == SLT || instr == SLTi)
//        return op1 < op2 ? 1 : 0;
//    else if (instr == SGT || instr == SGTi)
//        return op1 > op2 ? 1 : 0;
//    else if (instr == SLE || instr == SLEi)
//        return op1 <= op2 ? 1 : 0;
//    else if (instr == SGE || instr == SGEi)
//        return op1 >= op2 ? 1 : 0;
//    else if (instr == LD || instr == ST)                 // joj
//        return (se8(op1) + se8(op2)) & 0xFF;
//    else if (instr == JAL || instr == JALR)
//        return op2;
//    else
//        return 0xEE;

    if (instr == ADD)
        return (se8(op1) + se8(op2)) & 0xFF;
    else if (instr == SUB)
        return (se8(op1) - se8(op2)) & 0xFF;
    else if (instr == AND)
        return op1 & op2;
    else if (instr == ORR)
        return op1 | op2;
    else if (instr == EOR)
        return op1 ^ op2;
    else if (instr == LSL)
        return (op1 << op2) & 0xFF;
    else if (instr == LSR)
        return (op1 >> op2) & 0xFF;
    else if (instr == LDR || instr == STR)                 // joj
        return (se8(op1) + se8(op2)) & 0xFF;


//instrNames[ADC]	= "ADC";	// Add with Carry
	else if (instr == BIC)
		return (op1 & (~op2));
//instrNames[CMN]	= "CMN";	// Compare Negative
//instrNames[CMP]	= "CMP";	// Compare
//instrNames[MOV]	= "MOV";	// Move register or constant
//instrNames[MUL]	= "MUL";	// Multiply
//instrNames[MVN]	= "MVN";	// Move negative register
	else if (instr == RSB)
		return (se8(op2) - se8(op1)) & 0xFF;
//instrNames[RSC]	= "RSC";	// Reverse Subtract with Carry
//instrNames[SBC]	= "SBC";	// Subtract with Carry
//instrNames[ASR]	= "ASR";	// Arithmetic Shift RIght
	else if (instr == ASR) {
		num neg = op1 >> 7;
		if(op2 > 8) op2 = 8;	//If shifting by more than register size
		if(neg){
			op1 = op1 ^ 0xFF00;		//introduce ones before if negative to be shifted into place
		}
		return (op1 >> op2) & 0xFF;
	}
//instrNames[ROR]	= "ROR";	// Rotate Right
	else if (instr == ROR) {
		op2 = op2 % 8;		//modulo by max shift to remove need for loop
		num newLeftPart = (op1 << (8 - op2)) & 0xFF;
		num newRightPart = (op1 >> op2) & 0xFF;
		return newLeftPart + newRightPart;
	}
//instrNames[SWP]	= "SWP";	// Swap register with memory
//instrNames[TEQ]	= "TEQ";	// Test bitwise equality
//instrNames[TST]	= "TST";	// Test bits
//instrNames[LDM]	= "LDM";   // Load multiple registers
//instrNames[STM]	= "STM";   // Store Multiple
//instrNames[BX]	= "BX";   // Branch and Exchange




    else if (instr == B || instr == BL)
        return op2;
    else
        return 0xEE;
}

// eof