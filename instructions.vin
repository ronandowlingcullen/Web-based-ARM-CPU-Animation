//
// instructions.vin
//
// Simulation of the DLX
// Written by Edsko de Vries, Summer 2003
//
// Copyright (C) 2003 - 2018 Edsko de Vries and jones@scss.tcd.ie
//
// This program is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation;
// either version 2 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//

//
// Instruction constants
//

// Number of instructions (excluding "stall" instruction)
const num MAX_INSTR = 54;

// No-op
const num NOP = 0;

// Arithmetic/Logical/Shifting instructions (register-register)

const num ADD   = 1;    // Add
const num ADC	= 2;	// Add with Carry
const num SUB   = 3;    // Subtract
const num SBC	= 4;	// Subtract with Carry
const num RSB	= 5;	// Reverse Subtract
const num RSC	= 6;	// Reverse Subtract with Carry
const num MUL	= 7;	// Multiply

const num AND   = 8;    // Logical AND
const num ORR   = 9;    // Logical OR
const num EOR	= 10;	// Exclusive OR
const num BIC	= 11;	// Bit Clear

const num LSL	= 12;	// Logical Shift Left
const num LSR	= 13;	// Logical Shift Right
const num ASR	= 14;	// Arithmetic Shift RIght
const num ROR	= 15;	// Rotate Right


// Arithmetic/Logical/Shifting instructions (register-immediate)


const num ADDi  = 16;    // Add
const num ADCi	= 17;	// Add with Carry
const num SUBi  = 18;    // Subtract
const num SBCi	= 19;	// Subtract with Carry
const num RSBi	= 20;	// Reverse Subtract
const num RSCi	= 21;	// Reverse Subtract with Carry
const num MULi	= 22;	// Multiply

const num ANDi  = 23;    // Logical AND
const num ORRi  = 24;    // Logical OR
const num EORi	= 25;	// Exclusive OR
const num BICi	= 26;	// Bit Clear

const num LSLi	= 27;	// Logical Shift Left
const num LSRi	= 28;	// Logical Shift Right
const num ASRi	= 29;	// Arithmetic Shift RIght
const num RORi	= 30;	// Rotate Right


// Comparisons (register - register)
const num CMN	= 31;	// Compare Negative
const num CMP	= 32;	// Compare
const num TEQ	= 33;	// Test bitwise equality
const num TST	= 34;	// Test bits

// Comparisons (register - immediate)
const num CMNi	= 35;	// Compare Negative
const num CMPi	= 36;	// Compare
const num TEQi	= 37;	// Test bitwise equality
const num TSTi	= 38;	// Test bits



// Load/store instructions (register - register)
const num MOV	= 39;	// Move register or constant
const num MVN	= 40;	// Move negative register
const num LDR	= 41;   // Load register from memory
const num STR	= 42;   // Store register to memory
const num SWP	= 43;	// Swap register with memory

// Load/store instructions (register - immediate)
const num MOVi	= 44;	// Move register or constant
const num MVNi	= 45;	// Move negative register
const num LDRi	= 46;   // Load register from memory
const num STRi	= 47;   // Store register to memory


// Control instructions (register - register)
const num B		= 48;   // Branch
const num BL	= 49;   // Branch with Link

// Control instructions (register - immediate)
const num Bi	= 50;   // Branch
const num BLi	= 51;   // Branch with Link


// Halt
const num HALT  = 52;   // Stop running

// "Stall" and "Empty" instruction (aliases for NOP)
const num STALL = 53;
const num EMPTY = 54;

//
// Instruction names
//

string instrNames[55];

// NOP
instrNames[NOP] = "NOP";

// Arithmetic //instructions (register-register)
//instrNames[ADD] = "ADD";    // Add
//instrNames[SUB] = "SUB";    // Subtract
//instrNames[AND] = "AND";    // Logical AND
//instrNames[OR]  = "OR";     // Logical OR
//instrNames[XOR] = "XOR";    // Logical exclusive OR
//instrNames[SLL] = "SLL";    // Logical shift left
//instrNames[SRL] = "SRL";    // Logical shift right
//instrNames[SLT] = "SLT";    // Set if less than
//instrNames[SGT] = "SGT";    // Set if greater than
//instrNames[SLE] = "SLE";    // Set if less or equal
//instrNames[SGE] = "SGE";    // Set if greater or equal

// Arithmetic //instructions (register-immediate)
//instrNames[ADDi]    = "ADDi";
//instrNames[SUBi]    = "SUBi";
//instrNames[ANDi]    = "ANDi";
//instrNames[ORi]     = "ORi";
//instrNames[XORi]    = "XORi";
//instrNames[SLLi]    = "SLLi";
//instrNames[SRLi]    = "SRLi";
//instrNames[SLTi]    = "SLTi";
//instrNames[SGTi]    = "SGTi";
//instrNames[SLEi]    = "SLEi";
//instrNames[SGEi]    = "SGEi";

// Load/store //instructions
//instrNames[LD]      = "LD";     // Load             // joj
//instrNames[ST]      = "ST";     // Store            // joj

// Control //instructions
//instrNames[BEQZ]    = "BEQZ";   // Branch if equal to zero
//instrNames[BNEZ]    = "BNEZ";   // Branch if not equal to zero
//instrNames[J]       = "J";      // Jump
//instrNames[JAL]     = "JAL";    // Jump and link
//instrNames[JR]      = "JR";     // Jump register
//instrNames[JALR]    = "JALR";   // Jump and link register

instrNames[ADD] = "ADD";    // Add
instrNames[ADC]	= "ADC";	// Add with Carry
instrNames[SUB] = "SUB";    // Subtract
instrNames[SBC]	= "SBC";	// Subtract with Carry
instrNames[RSB]	= "RSB";	// Reverse Subtract
instrNames[RSC]	= "RSC";	// Reverse Subtract with Carry
instrNames[MUL]	= "MUL";	// Multiply

instrNames[AND] = "AND";    // Logical AND
instrNames[ORR] = "ORR";    // Logical OR
instrNames[EOR]	= "EOR";	// Exclusive OR
instrNames[BIC]	= "BIC";	// Bit Clear
instrNames[LSL]	= "LSL";	// Logical Shift Left
instrNames[LSR]	= "LSR";	// Logical Shift Right
instrNames[ASR]	= "ASR";	// Arithmetic Shift RIght
instrNames[ROR]	= "ROR";	// Rotate Right


// Arithmetic/Logical/Shifting instructions (register-immediate)


instrNames[ADDi] = "ADD(i)";    // Add
instrNames[ADCi] = "ADC(i)";	// Add with Carry
instrNames[SUBi] = "SUB(i)";    // Subtract
instrNames[SBCi] = "SBC(i)";	// Subtract with Carry
instrNames[RSBi] = "RSB(i)";	// Reverse Subtract
instrNames[RSCi] = "RSC(i)";	// Reverse Subtract with Carry
instrNames[MULi] = "MUL(i)";	// Multiply

instrNames[ANDi] = "AND(i)";    // Logical AND
instrNames[ORRi] = "ORR(i)";    // Logical OR
instrNames[EORi] = "EOR(i)";	// Exclusive OR
instrNames[BICi] = "BIC(i)";	// Bit Clear

instrNames[LSLi] = "LSL(i)";	// Logical Shift Left
instrNames[LSRi] = "LSR(i)";	// Logical Shift Right
instrNames[ASRi] = "ASR(i)";	// Arithmetic Shift RIght
instrNames[RORi] = "ROR(i)";	// Rotate Right


// Comparisons (register - register)
instrNames[CMN]	= "CMN";	// Compare Negative
instrNames[CMP]	= "CMP";	// Compare
instrNames[TEQ]	= "TEQ";	// Test bitwise equality
instrNames[TST]	= "TST";	// Test bits

// Comparisons (register - immediate)
instrNames[CMNi]	= "CMN(i)";	// Compare Negative
instrNames[CMPi]	= "CMP(i)";	// Compare
instrNames[TEQi]	= "TEQ(i)";	// Test bitwise equality
instrNames[TSTi]	= "TST(i)";	// Test bits


// Load/store instructions (register - register)
instrNames[MOV]	= "MOV";	// Move register or constant
instrNames[MVN]	= "MVN";	// Move negative register
instrNames[LDR]	= "LDR";   // Load register from memory
instrNames[STR]	= "STR";   // Store register to memory
instrNames[SWP]	= "SWP";	// Swap register with memory

// Load/store instructions (register - immediate)
instrNames[MOVi]	= "MOV(i)";	// Move register or constant
instrNames[MVNi]	= "MVN(i)";	// Move negative register
instrNames[LDRi]	= "LDR(i)";   // Load register from memory
instrNames[STRi]	= "STR(i)";   // Store register to memory


// Control instructions (register - register)
instrNames[B]	= "B";   // Branch
instrNames[BL]	= "BL";   // Branch with Link

// Control instructions (register - register)
instrNames[Bi]	= "B(i)";   // Branch
instrNames[BLi]	= "BL(i)";   // Branch with Link


// Halt
instrNames[HALT]    = "HALT";

// "Stall" instruction
instrNames[STALL]   = "STALL";
instrNames[EMPTY] = "EMPTY";

//
// Instruction classes
//
num function instrIsNop(num instr) {
    return (instr == NOP || instr == STALL || instr == EMPTY || instr == HALT) ? 1 : 0; // {joj 28/10/06}
}

num function instrIsArRR(num instr) {
    //return (instr >= ADD && instr <= SGE) ? 1 : 0;          // {joj 28/10/06}
	return (instr >= ADD && instr <= ROR) ? 1 : 0;
}

num function instrIsArRI(num instr) {
    return ((instr >= ADDi) && (instr <= RORi)) ? 1 : 0;	// {joj 28/10/06}
	return 0;
}

num function instrIsBranch(num instr) {
    //return ((instr == BEQZ) || (instr == BNEZ)) ? 1 : 0;    // {joj 28/10/06}
	return (instr >= B && instr <= BLi) ? 1 : 0;
}

//num function isJorJAL(num instr) {							// {joj 3/11/12}
//    //return ((instr == J) || (instr == JAL)) ? 1 : 0;        // {joj 28/10/06}
//	return ((instr == B) || (instr == BL)) ? 1 : 0;
//}

//num function instrIsJumpR(num instr) {						
    //return ((instr == JR) || (instr == JALR)) ? 1 : 0;		// {joj 28/10/06}
//	return 0;
//}

//num function instrIsBranchOrJump(num instr) {
//    return (instrIsBranch(instr) || isJorJAL(instr) || instrIsJumpR(instr)) ? 1 : 0;    // {joj 28/10/06}
//}

//num function instrIsJumpAndLink(num instr) {
    //return ((instr == JAL) || (instr == JALR)) ? 1 : 0;     // {joj 28/10/06}
//    return (instr == BL) ? 1 : 0;     // {joj 28/10/06}
//}

num function instrIsLoadOrStore(num instr) {
    //return ((instr == LD) || (instr == ST)) ? 1 : 0;            // {joj 28/10/06}
    return ((instr == LDR) || (instr == STR)) ? 1 : 0;            // {joj 28/10/06}
}

// My ones
// Shift immediate

num function instrIsShI(num instr) {
	return (instr >= LSLi && instr <= RORi) ? 1 : 0;
}

// instructions with no destination register Register - Register
num function instrHasNoDstRR(num instr) {
	return ((instr >= CMN && instr <= TST) || (instr >= MOV && instr <= SWP) || instrIsBranch(instr)) ? 1 : 0;
}

// instructions with no destination register Register - Immediate
num function instrHasNoDstRI(num instr) {
	return ((instr >= CMNi && instr <= TSTi) || (instr >= MOVi && instr <= STRi) || instrIsBranch(instr)) ? 1 : 0;
}


//
// Instruction operand types
//
const num OP_TYPE_UNUSED = 0;
const num OP_TYPE_REG = 1;
const num OP_TYPE_IMM = 2;

num function instrOpTypeRdt(num instr) {
    if (instrIsNop(instr) || instrHasNoDstRR(instr) || instrHasNoDstRI(instr))
        return OP_TYPE_UNUSED;
    else
        return OP_TYPE_REG;
}

num function instrOpTypeRs1(num instr) {
    if (instrIsNop(instr))
        return OP_TYPE_UNUSED;
	else if (instr == Bi || instr == BLi)
		return OP_TYPE_IMM;
    else
        return OP_TYPE_REG;
}

num function instrOpTypeRs2(num instr) {
    if (instrIsNop(instr) || instrIsBranch(instr))
        return OP_TYPE_UNUSED;
    else if (instrIsArRR(instr) || instrHasNoDstRR(instr))
        return OP_TYPE_REG;
    else
        return OP_TYPE_IMM;
}

num function instrOpTypeRs3(num instr2) {
    if (instrIsNop(instr2))
        return OP_TYPE_UNUSED;
    else if (instrIsShI(instr2))
        return OP_TYPE_IMM;
    else
        return OP_TYPE_REG;
}

//
// Instruction formatting
//
//string function instrText(num instr, num rdt, num rs1, num rs2) {				// {joj 28/10/10}
//    if (instrIsNop(instr))
//        return sprintf("%s", instrNames[instr]);                             	// {joj 28/10/10}
//    else if (instrIsArRR(instr))
//        return sprintf("%s R%d,R%d,R%d", instrNames[instr], rdt, rs1, rs2);  	// {joj 28/10/10}
//    else if (instrIsArRI(instr))
//        return sprintf("%s R%d,R%d,%02X", instrNames[instr], rdt, rs1, rs2); 	// {joj 28/10/10}
//    else if (instr == LD)														// {joj}
//       return sprintf("LD R%d,R%d+%02X", rdt, rs1, rs2);                     	// {joj 28/10/06}
//    else if (instr == ST)                                                		// {joj 28/10/06}
//        return sprintf("ST R%d,R%d+%02X", rdt, rs1, rs2);                    	// {joj 28/10/06}
//    else if (instrIsBranch(instr))
//        return sprintf("%s R%d,%02X", instrNames[instr], rs1, rs2);          	// {joj 28/10/10}
//    else if (instr == J)
//        return sprintf("%s %02X", instrNames[instr], rs2);                   	// {joj 28/10/10}
//    else if (instr == JAL)
//        return sprintf("%s R%d, %02X", instrNames[instr], rdt, rs2);         	// {joj 28/10/10}
//    else if (instr == JR)
//        return sprintf("%s R%d", instrNames[instr], rs2);                    	// {joj 28/10/10}
//    else if (instr == JALR)
//        return sprintf("%s R%d, R%d", instrNames[instr], rdt, rs2);          	// {joj 28/10/10}
//    return "EMPTY";                                                         	// {joj 28/10/10}
//}

string function instrText(num instr, num rdt, num rs1, num rs2, num instr2, num rs3) {				// {joj 28/10/10}
    if (instrIsNop(instr))
        return sprintf("%s", instrNames[instr]);                             	// {joj 28/10/10}
    else if (instrIsArRR(instr))
        return sprintf("%s R%d,R%d,R%d", instrNames[instr], rdt, rs1, rs2);  	// {joj 28/10/10}
    else if (instrIsArRI(instr))
        return sprintf("%s R%d,R%d,%02X", instrNames[instr], rdt, rs1, rs2); 	// {joj 28/10/10}
    else if (instr == LDR)														// {joj}
       return sprintf("LDR R%d,R%d+%02X", rdt, rs1, rs2);                     	// {joj 28/10/06}
    else if (instr == STR)                                                		// {joj 28/10/06}
        return sprintf("STR R%d,R%d+%02X", rdt, rs1, rs2);                    	// {joj 28/10/06}
    else if (instrIsBranch(instr))
        return sprintf("%s R%d,%02X", instrNames[instr], rs1, rs2);          	// {joj 28/10/10}
    else if (instr == B)
        return sprintf("%s %02X", instrNames[instr], rs2);                   	// {joj 28/10/10}
    else if (instr == BL)
        return sprintf("%s R%d, %02X", instrNames[instr], rdt, rs2);         	// {joj 28/10/10}
    return "EMPTY";                                                         	// {joj 28/10/10}
}

//
// Execution
//

// 8-bit sign extension
num function se8(num t) {
    if (t & 0x80)
        return (-1 ^ 0xFF | t);
    else
        return t;
}


// Check Condition Codes
num function isN(num val){
	if(val & 0x80)
		return 1;
	else
		return 0;
}

num function isZ(num val){
	if(val == 0)
		return 1;
	else
		return 0;
}

num function isAddC(num op1, num op2){
	if((op1 + op2) & 0x100)
		return 1;
	else
		return 0;
}

num function isSubC(num op1, num op2){
	if((op1 + op2) & 0x100)
		return 0;
	else
		return 1;
}

num function isAddV(num op1, num op2, num res){
	if(((op1 & 0x80) == (op2 & 0x80)) && ((res & 0x80) != (op1 & 0x80)))
		return 1;
	else
		return 0;
}

num function isSubV(num op1, num op2, num res){
	if(((op1 & 0x80) != (op2 & 0x80)) && ((res & 0x80) != (op1 & 0x80)))
		return 1;
	else
		return 0;
}

num function instrExecute(num instr, num op1, num op2, num n, num z, num c, num v) {
//    if (instr == ADD || instr == ADDi)
//        return (se8(op1) + se8(op2)) & 0xFF;
//    else if (instr == SUB || instr == SUBi)
//        return (se8(op1) - se8(op2)) & 0xFF;
//    else if (instr == AND || instr == ANDi)
//        return op1 & op2;
//    else if (instr == OR || instr == ORi)
//        return op1 | op2;
//    else if (instr == XOR || instr == XORi)
//        return op1 ^ op2;
//    else if (instr == SLL || instr == SLLi)
//        return (op1 << op2) & 0xFF;
//    else if (instr == SRL || instr == SRLi)
//        return (op1 >> op2) & 0xFF;
//    else if (instr == SLT || instr == SLTi)
//        return op1 < op2 ? 1 : 0;
//    else if (instr == SGT || instr == SGTi)
//        return op1 > op2 ? 1 : 0;
//    else if (instr == SLE || instr == SLEi)
//        return op1 <= op2 ? 1 : 0;
//    else if (instr == SGE || instr == SGEi)
//        return op1 >= op2 ? 1 : 0;
//    else if (instr == LD || instr == ST)                 // joj
//        return (se8(op1) + se8(op2)) & 0xFF;
//    else if (instr == JAL || instr == JALR)
//        return op2;
//    else
//        return 0xEE;





	num res = 0;				// Init result to zero		

    if (instr == ADD || instr == ADDi)
        return (se8(op1) + se8(op2)) & 0xFF;
    else if (instr == SUB || instr == SUBi)
        return (se8(op1) - se8(op2)) & 0xFF;
    else if (instr == AND || instr == ANDi)
        return op1 & op2;
    else if (instr == ORR || instr == ORRi)
        return op1 | op2;
    else if (instr == EOR || instr == EORi)
        return op1 ^ op2;
    else if (instr == LSL || instr == LSLi)
        return (op1 << op2) & 0xFF;
    else if (instr == LSR || instr == LSRi)
        return (op1 >> op2) & 0xFF;
    else if (instr == LDR || instr == LDRi || instr == STR || instr == STRi)                 // joj
        return (se8(op1) + se8(op2)) & 0xFF;
	else if (instr == ADC || instr == ADCi)
        return (se8(op1) + se8(op2) + c) & 0xFF;
	else if (instr == BIC || instr == BICi)
		return (op1 & (~op2));
	else if (instr == CMN || instr == CMNi) {
		res = se8(op1) + se8(op2);
		cpsr.setNValue(isN(res));
		cpsr.setZValue(isZ(res));
		cpsr.setCValue(isAddC(se8(op1),se8(op2)));
		cpsr.setVValue(isAddV(se8(op1),se8(op2),res));
	}
	else if (instr == CMP || instr == CMPi) {
		res = se8(op1) - se8(op2);
		cpsr.setNValue(isN(res));
		cpsr.setZValue(isZ(res));
		cpsr.setCValue(isSubC(se8(op1),se8(op2)));
		cpsr.setVValue(isSubV(se8(op1),se8(op2),res));
	}
//instrNames[MOV]	= "MOV";	// Move register or constant
//instrNames[MUL]	= "MUL";NB:	// Multiply ********(If S set V preserved)******************
//instrNames[MVN]	= "MVN";	// Move negative register
	else if (instr == RSB || instr == RSBi)
		return (se8(op2) - se8(op1)) & 0xFF;
	else if (instr == RSC || instr == RSCi)
		return (se8(op2) - se8(op1)-1+c) & 0xFF;
	else if (instr == SBC || instr == SBCi)
		return (se8(op1) - se8(op2)-1+c) & 0xFF;
	else if (instr == ASR || instr == ASRi) {
		num neg = op1 >> 7;
		if(op2 > 8) op2 = 8;	//If shifting by more than register size
		if(neg){
			op1 = op1 ^ 0xFF00;		//introduce ones before if negative to be shifted into place
		}
		return (op1 >> op2) & 0xFF;
	}
	else if (instr == ROR || instr == RORi) {
		op2 = op2 % 8;		//modulo by max shift to remove need for loop
		num newLeftPart = (op1 << (8 - op2)) & 0xFF;
		num newRightPart = (op1 >> op2) & 0xFF;
		return newLeftPart + newRightPart;
	}
//instrNames[SWP]	= "SWP";	// Swap register with memory
	else if (instr == TEQ || instr == TEQi) {
		res = se8(op1) ^ se8(op2);
		cpsr.setNValue(isN(res));
		cpsr.setZValue(isZ(res));
		cpsr.setCValue(isAddC(se8(op1),se8(op2)));
		cpsr.setVValue(isAddV(se8(op1),se8(op2),res));
	}
	else if (instr == TST || instr == TSTi) {
		res = se8(op1) & se8(op2);
		cpsr.setNValue(isN(res));
		cpsr.setZValue(isZ(res));
		cpsr.setCValue(isAddC(se8(op1),se8(op2)));
		cpsr.setVValue(isAddV(se8(op1),se8(op2),res));
	}
    else if (instr == B || instr == BL)
        return op2;
    else
        return 0xEE;
}

// eof